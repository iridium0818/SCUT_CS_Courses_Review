# **Web**基础知识

## HTML基本概念

hyper-text-markup-language超文本**标记**语言

浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。

HTML5的设计目的是为了在移动设备上支持多媒体。

CSS（层叠样式表）的三种引入方式：

1. 内联样式（直接写）
2. 内部样式（定义在当前页面内，再调用）
3. 外部样式（外面定义，引入css）

CSS是能够真正做到网页表现与内容分离的一种样式设计语言。

## HTTP协议

### 基于请求-响应的无状态的协议

过程：

1. http客户端发送http请求
2. 服务端处理客户端请求，发回http响应
3. 客户端处理响应，关闭连接

特征：无连接（服务器处理完请求并收到客户端应答后即断开）；媒体独立的（只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过 HTTP 发送）；无状态的（对事务处理无记忆能力）

报文结构：请求与响应的组成  
- HTTP 请求 (Request)  
请求行： 包含方法（如 GET）、URL（地址）和协议版本。  
请求头部： 包含客户端环境信息（如：用的什么浏览器、接受什么语言）。  
空行： 必须有的分隔符，告诉服务器“头部结束了，下面是正文”。  
请求数据 (Body)： 比如你在登录框输入的账号密码。  
- HTTP 响应 (Response)  
状态行： 协议版本 + 状态码（如 200 OK）。  
消息报头： 服务器信息、数据类型、数据长度等。  
空行： 分隔符。  
响应正文： 浏览器渲染出来的 HTML 页面、图片或 JSON 数据。  

请求方法：8种请求类型，但最常用的是前两种：  
- GET：向特定资源发送请求
- POST：向指定资源提交数据进行处理请求
- 其他： PUT (更新)、DELETE (删除)、HEAD (只获取报头) 等。

状态码：三位数字组成，第一位决定类型；2-成功 3-重定向 4-客户端错误 5-内部服务器错误

## Tomcat的基本概念、配置、部署

### JSP 和 Servlet 的实现

Tomcat 的核心身份是 **Servlet 容器**（也叫 Web 容器）。

- **Servlet：** 是用 Java 编写的服务器端程序。你可以把它理解为“处理逻辑的机器”，比如接收登录请求、查询数据库。
- **JSP (JavaServer Pages)：** 是一种在 HTML 中嵌入 Java 代码的技术。
- **关系：** 浏览器无法直接运行 Java。Tomcat 的作用就是接收请求，调用对应的 Servlet 处理业务，或者将 JSP 编译成 Servlet 转换为 HTML 网页发回给浏览器。

### 作为 Web 服务器运行的能力

虽然 Tomcat 主要用于运行 Java 程序，但它也具备 **Web 服务器**（如 Apache 或 Nginx）的功能，能够处理静态资源（HTML、图片、CSS）。

- **现实应用：** 在大型项目中，通常用 Nginx 处理静态资源，而将动态请求（Java 逻辑）转发给 Tomcat。

### 环境配置：运行的前提

必须安装 JRE (Java Runtime Environment)

Tomcat 本身是用 Java 编写的，因此它不能直接在操作系统上运行，必须运行在 Java 虚拟机（JVM）之上。

- **扩展：** 通常建议安装 **JDK**（Java Development Kit），因为 JDK 包含了 JRE，并且在编译 JSP 文件时，JDK 提供的工具更加完整。
- **环境变量：** 安装后需要配置 `JAVA_HOME` 环境变量，告诉 Tomcat 到哪里去找 Java。

### 核心配置：`/conf/server.xml`

这是 Tomcat 最核心的配置文件，负责定义服务器如何启动、监听哪个端口。

#### 修改默认端口号

- **默认端口 8080：** 安装后的默认访问地址是 `http://localhost:8080`。
- **修改为 80 端口：** 在 `server.xml` 中找到 `Connector` 标签，将 `port="8080"` 改为 `port="80"`。
- **为什么要改？** 80 端口是 HTTP 协议的**默认端口**。修改后，用户访问网站时就无需在域名后手动输入端口号（例如直接输入 `www.example.com` 即可）。

XML

```
<Connector port="80" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443" />
```


### 部署方式 (Deployment)

在 Tomcat 中部署项目主要有以下三种方式：

1. 直接放到 webapps 目录下：

   这是最简单的方式。将你的项目文件夹或打包好的 .war 文件放入 webapps 目录，Tomcat 启动时会自动解压并运行。

2. 修改 server.xml：

   在`<Host>`标签内添加`<Context>`标签，手动指定项目所在的本地路径。

3. 创建独立的 XML 文件：

   在 conf/Catalina/localhost/ 目录下创建一个 XML 文件。这种方式最灵活，不需要修改主配置文件，也不会因为改错代码导致服务器无法启动。


### 目录结构概览

了解 Tomcat 文件夹的用途是维护的关键：

| **目录名**   | **用途**                                                     |
| ------------ | ------------------------------------------------------------ |
| **/bin**     | 存放启动 (`startup.bat/sh`) 和关闭 (`shutdown.bat/sh`) 脚本。 |
| **/conf**    | 存放配置文件，如 `server.xml` (核心配置) 和 `web.xml`。      |
| **/lib**     | 存放 Tomcat 运行所需的 Jar 包。                              |
| **/logs**    | 存放运行日志，排查错误必看。                                 |
| **/webapps** | **核心目录**，存放你开发的 Web 项目。                        |
| **/work**    | 存放 JSP 编译后生成的 Class 文件。                           |

## MVC设计模式

MODEL-VIEW-CONTROLLER

### 组成

控制器：转发请求，处理请求（接口？）

视图：图形界面设计

模型：编写程序的功能，管理数据；

### MVC设计模式优点

1. 多视图共享模型，提高代码的可重用性
2. 三个部分相互独立，松耦合
3. 专业人员可以根据专长分组
4. 利于软件工程化管理
5. 可以方便的改变应用程序的数据层和业务规则（只用对模型做出更改）， 提高了应用程序的灵活性和可配置性

### 两种设计模式

#### JSP MODEL 1

JSP（view+controller）+JavaBean(模型)

优点：实现简单、可快速开发；

缺点：JSP身兼view controller两个角色，控制逻辑和表现逻辑混合，代码重用度低

#### JSP MODEL 2（更好的）

JSP（view）+servlet（controller）+JavaBeans（model）

松耦合！



## Servlet：服务器端小程序

### Servelet基本概念：运行在Web服务器端的java程序（eg.tomcat)

是java企业版的标准组成部分

Java Servlet 就像任何其他的 Java 类一样已经被创建和编译（正常的类一样编写，编译后再使用）

##### 主要功能：

1. 读取用户提交的数据（**显式**）/浏览器发送的**隐式**数据
2. 生成结果：得到用于响应的信息
3. 向客户发送**显式**数据/像浏览器发送**隐式**的数据

##### 优势：

使用Java类库的全部功能（毕竟是java程序）

使用Web服务器的地址空间，即多个处理线程共享地址空间

##### 工作原理：

![image-20231217160100135](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231217160100135.png)

1. 服务器接收到客户端请求 创建request/response对象
2. 存在servlet则直接调用servlet方法
3. 不存在servlet则创建servlet（加载和实例化、初始化），调用servlet方法
4. servlet方法处理请求然后进行响应，返回结果给客户端

### HttpServlet类

类别关系：

- Servlet=>GenericServlet=>HttpServlet
- ServletRequest=>HttpServletRequest
- ServletResponse=>HttpServletResponse

处理请求：针对不同http请求有不同处理方法(好像一般是public方法)

```java
protected void doGet(HttpServletRequest, HttpServletResponse) throws ServletException,IOException
```

通过@Override覆盖原本的方法，直接覆盖do方法，不用覆盖service方法；

#### 生命周期（由web容器管理！）

1. 加载

2. 实例化

3. 初始化init：使用ServletConfig对象初始化

   ```java
   public void init(ServletConfig config) throws ServletException
   ```

4. 处理请求service：接受request和response

   ```java
   public void service(ServletRequest request, ServletResponse response)   
                          throws ServletException, IOException
   ```

5. 销毁destroy

   ```java
   public void destroy()
   ```

### ServletContext接口

每个web应用对应一个ServletContext（作用域:application)

可以获取web程序的初始化信息，读取资源文件等；

从web.xml获取配置信息

| 序号 | 方法                                                | 描述                                |
| ---- | --------------------------------------------------- | ----------------------------------- |
| 1    | public String getInitParameter(String name)         | 返回指定参数名称的参数值            |
| 2    | public Enumeration getInitParameterNames()          | 返回上下文的初始化参数的名称        |
| 3    | public void setAttribute(String name,Object object) | 在应用程序范围内设置给定的对象      |
| 4    | public Object getAttribute(String name)             | 返回指定名称的属性                  |
| 5    | public void removeAttribute(String name)            | 从servlet上下文中删除给定名称的属性 |

### ServletConfig接口

| 方法                                 | 用途                                          |
| ------------------------------------ | --------------------------------------------- |
| String getServletName()              | 获取当前Servlet在web.xml中配置的名字          |
| String getInitParameter(String name) | 获取当前Servlet指定名称的初始化参数的值       |
| Enumeration getInitParameterNames()  | 获取当前Servlet所有初始化参数的名字组成的枚举 |
| ServletContext getServletContext()   | 获取代表当前web应用的ServletContext对象       |

 servlet对象内可以直接调用getServletContext获取上下文，或者是通过他的getServletConfig.getServletContext也可以获取

上下文存储的是servlet相关的环境信息，属性、日志等。

### HttpServletRequest和HttpServletResponse对象

request:请求行（方法，协议，uri）请求头：（发送的一些状态信息eg.User-Agent）

get限制表单数据为ASCII post不限制

get请求数据下载URL之后

header就是保存请求状态的

| 方法声明                            | 功能描述                                                     |
| ----------------------------------- | ------------------------------------------------------------ |
| String getHeader(String name)       | 该方法用于获取一个指定头字段的值，如果请求消息中没有包含指定的头字段，getHeader()方法返回null；如果请求消息中包含有多个指定名称的头字段，getHeader()方法返回其中第一个头字段的值 |
| Enumeration getHeaders(String name) | 该方法返回一个Enumeration集合对象，该集合对象由请求消息中出现的某个指定名称的所有头字段值组成。在多数情况下，一个头字段名在请求消息中只出现一次，但有时候可能会出现多次 |
| Enumeration getHeaderNames()        | 该方法用于获取一个包含所有请求头字段的Enumeration对象        |
| int getIntHeader(String name)       | 该方法用于获取指定名称的头字段，并且将其值转为int类型。需要注意的是，如果指定名称的头字段不存在，返回值为-1；如果获取到的头字段的值不能转为int类型，将发生NumberFormatException异常 |
| Long getDateHeader(String name)     | 该方法用于获取指定头字段的值，并将其按GMT时间格式转换成一个代表日期/时间的长整数，这个长整数是自1970年1月1日0点0分0秒算起的以毫秒为单位的时间值 |

| 方法声明                                 | 功能描述                                                     |
| ---------------------------------------- | ------------------------------------------------------------ |
| String getParameter(String name)         | 该方法用于获取某个指定名称的参数值，如果请求消息中没有包含指定名称的参数，getParameter()方法返回null；如果指定名称的参数存在但没有设置值，则返回一个空串；如果请求消息中包含有多个该指定名称的参数，getParameter()方法返回第一个出现的参数值 |
| String[] getParameterValues(String name) | HTTP请求消息中可以有多个相同名称的参数（通常由一个包含有多个同名的字段元素的FORM表单生成），如果要获得HTTP请求消息中的同一个参数名所对应的所有参数值，那么就应该使用getParameterValues()方法，该方法用于返回一个String类型的数组 |
| Enumeration getParameterNames()          | getParameterNa mes()方法用于返回一个包含请求消息中所有参数名的Enumeration对象，在此基础上，可以对请求消息中的所有参数进行遍历处理 |
| Map getParameterMap()                    | getParameterMap()方法用于将请求消息中的所有参数名和值装入进一个Map对象中返回 |

response

两种输出方法：getOutputStream=>OutputStream getWriter=>PrintWriter

使用outputstream:

response.setheader("content-type","text/html;charset=UTF-8")

response.getOutputStream().write(data.getbytes("utf-8"))



使用printwriter:

response.setheader("content-type","text/html;charset=utf-8") 通知对面用utf-8解码

response.setcharacterencoding("utf-8") 以utf-8编码

response.getwriter().write(data) 写入data



#### redirect

```java
1 public void HttpServletResponse.sendRedirect(String location) /
2                              throws IOException
```

#### dispatcher

**RequestDispatcher** 是一个Web资源的包装器， 可以用来把当前 **request** 传递到该资源，或者把新的资源包括到当前响应中。 资源可是 **html**，**servlet** 或 **jsp** 等。

**让其它的资源参与进来，协同完成的响应**

```java
1 RequestDispatcher rd=request.getRequestDispatcher("servlet2");  
2 //servlet2 is the url-pattern of the second servlet  
3 rd.forward(request, response);//method may be include or forward
```

forward请求转发 include包含额外的请求资源

#### Filter过滤器：可过滤web jsp html

![image-20231217190738287](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231217190738287.png)

在request到达servlet前拦截修改

在response到达客户端前拦截修改

```java
public void doFilter(ServletRequest,ServletResponse,FilterChain)
public void init(FilterConfig)
public void destroy()
```

##### 生命周期

加载、实例化=>初始化=>doFilter=>销毁

```java
public class filter implements Filter{...doFilter}
```

#### Listener

**Listener**就是一个实现特定接口的**java**程序，这个程序专门用于监听另一个**java**对象的**方法调用或属性改变**，当被监听对象发生如Web应用的启动和停止、用户**Session**的开始和结束等事件后，监听器某个方法将立即被执行。

![image-20231217192246156](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20231217192246156.png)

| 接口名称                        | 作用                                                  |
| ------------------------------- | ----------------------------------------------------- |
| ServletContextListener          | 用于监听Web应用的启动和关闭                           |
| ServletContextAttributeListener | 用于监听ServletContext范围（application）内属性的改变 |
| ServletRequestListener          | 用于监听用户请求                                      |
| ServletRequestAttributeListener | 用于监听ServletRequest范围（request）内属性的改变     |
| HttpSessionListener             | 用于监听用户Session的开始和结束                       |
| HttpSessionAttributeListener    | 用于监听HttpSession范围（session）内属性的改变        |

生命周期：实例化=>初始化=>调用=>销毁

### Cookie、Session

### cookie

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据。它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

- **存储位置：** 用户的浏览器（硬盘或内存）。
- **工作流程：**
  1. 你访问网站并登录。
  2. 服务器在响应头中加入 `Set-Cookie` 字段。
  3. 浏览器把这段数据存起来。
  4. 下次访问时，浏览器自动在请求头中加上 `Cookie` 字段发送给服务器。

### Session

Session 代表服务器与客户端之间的一次“会话”。它将数据保存在服务器端。

- **存储位置：** 服务器内存或数据库中。
- **工作流程：**
  1. 用户登录后，服务器创建一个 Session 对象，生成一个唯一的 **Session ID**。
  2. 服务器通过 Cookie 将这个 Session ID 发送给客户端。
  3. 客户端后续请求都会带着这个 ID。
  4. 服务器根据 ID 找到对应的 Session，从而获取用户信息。

### Cookie 与 Session 的区别

虽然它们通常配合使用，但在多个维度上有显著不同：

| **特性**       | **Cookie**                                         | **Session**                                      |
| -------------- | -------------------------------------------------- | ------------------------------------------------ |
| **存储位置**   | 客户端（浏览器）                                   | 服务端                                           |
| **安全性**     | **较低**。数据可见且易被篡改或盗取。               | **较高**。敏感数据留在服务器，客户端只拿 ID。    |
| **数据类型**   | 只能存 **字符串**（且大小通常限制在 4KB）。        | 可以存 **任意对象**（Java 里的 Map、List 等）。  |
| **服务器资源** | 不占用服务器资源。                                 | 占用服务器内存，用户多时会产生压力。             |
| **有效期**     | 可长期保存（设置过期时间），浏览器关闭后依然存在。 | 通常较短，随会话结束或超时（默认 30 分钟）销毁。 |


### Cookie 与 Session 是如何“配合”的？

可以用一个生活中的例子来理解：

- **Session** 就像是健身房的**后台管理系统**，里面存着你的剩余课时、身体数据。
- **Cookie** 就像是你手里的那张**会员卡**（上面只印着你的卡号，即 Session ID）。

当你去健身房（发起请求）时，你出示会员卡（Cookie），前台在电脑（Session）里搜一下卡号，就知道你是谁、还有多少课了。**如果没有会员卡，后台系统存再多数据也对不上号。**

#### 常见问题：如果浏览器禁用了 Cookie，Session 还能用吗？

默认情况下不能，因为 Session ID 传不过去。但可以通过其他手段补救，比如 **URL 重写**：将 Session ID 直接拼接在网址后面（例如 `www.example.com/index.jsp;jsessionid=12345`）。

# JSP

## JSP基本概念

JSP是一种servlet，用来实现java web程序的ui部分（前端）

JSP可以直接在ｈｔｍｌ网页中动态嵌入元素不需要CGI文件

JSP是JAVA EE不可或缺的部分，是一个完整的企业级应用平台

### 使用JSP创建网页的步骤

ｗｅｂ服务器中需要有ｊｓｐ容器负责提供ｊｓｐ环境，正确识别ｊｓｐ元素

1.　客户端发送ｇｅｔ请求ｊｓｐ文件
2.　ｊｓｐ文件被转为ｓｅｒｖｌｅｔ（将文本转为ｐｒｉｎｔｌｎ，ｊｓｐ元素转成ｊａｖａ代码）
3.　编译ｓｅｒｖｌｅｔ，ｓｅｒｖｌｅｔ引擎
4.　ｓｅｒｖｌｅｔ引擎被调用，对请求进行处理
5.　返回给浏览器

简洁来说：．ｊｓｐ＝＞．ｊａｖａ＝＞编译得到ｓｅｒｖｌｅｔ＝＞ｓｅｒｖｌｅｔ执行请求＝＞返回

### ｊｓｐ生命周期

ｉｎｉｔ＝＞ｓｅｒｖｉｃｅ＝＞ｄｅｓｔｒｏｙ

ｊｓｐＩｎｉｔ，＿ｊｓｐＳｅｒｖｉｃｅ，ｊｓｐＤｅｓｔｏｒｙ

### ｊｓｐ基本语法

元素包含：指令、脚本、动作、表达式语言

#### 脚本：ｊａｖａ代码

脚本包括：声明！，表达式＝，脚本小程序

##### 声明：＜％！（带感叹号的是声明）

```ｊａｖａ
＜％！　ｉｎｔ　ｉ＝０；％＞
```

JSP容器内的成员变量在容器内被共享，多个用户请求同一个JSP页面，是通过线程处理请求的，因此成员变量会相互影响。

#### 表达式＜％＝

＜％＝｛ｅｘｐｒｅｓｓｉｏｎ｝％＞

#### ＪＳＰ注释<％－－注释－－％＞

#### ＪＳＰ指令＜％　％＞

＜％　％＞直接包含要执行的ｊａｖａ语句即可，按照顺序被ｓｅｒｖｌｅｔ的＿ｊｓｐＳｅｒｖｉｃｅ执行

＜％＠　ｐａｇｅ／ｉｎｃｌｕｄｅ／ｔａｇｌｉｂ　％＞用于设置页面属性（全局？）

＜％＠　ｉｎｃｌｕｄｅ　ｆｉｌｅ＝＂ｕｒｌ＂％＞

＜％＠　ｔａｇｌｉｂ　ｐｒｅｆｉｘ＝＂　＂　ｕｒｉ＝＂　＂％＞

#### ＪＳＰ动作：请求处理阶段起作用

用ｘｍｌ编写

＜ｊｓｐ：ａｃｔｉｏｎ＿ｎａｍｅ　ａｔｔｒｉｂｕｔｅ＝＂ｖａｌｕｅ＂＞

##### ｊｓｐ：ｉｎｃｌｕｄｅ　用于将文件插入页面

＜ｊｓｐ：ｉｎｃｌｕｄｅ　ｐａｇｅ＝＂ｕｒｌ＂　ｆｌｕｓｈ＝＂ｔｒｕｅ＂＞

##### ｊｓｐ：ｕｓｅＢｅａｎ　使用某些ｂｅａｎ

＜ｊｓｐ：ｕｓｅＢｅａｎ　ｉｄ＝ｍｙｉｄ　ｃｌａｓｓ＝　＞

＜ｊｓｐ：ｓｅｔＰｒｏｐｅｒｔｙ　ｎａｍｅ＝ｍｙｉｄ　ｐｒｏｐｅｒｔｙ＝　ｖａｌｕｅ＝＞

＜ｊｓｐ：ｇｅｔＰｒｏｐｅｒｔｙ　ｎａｍｅ＝ｍｙｉｄ　ｐｒｏｐｅｒｔｙ＝＞

##### ｊｓｐ：ｆｏｒｗａｒｄ

＜ｊｓｐ：ｆｏｒｗａｒｄ　ｐａｇｅ＝＞

ｐａｇｅ后面接ｕｒｌ　ｊｓｐ都可以

##### ｊｓｐ：ｐｌｕｇｉｎ

＜ｊｓｐ：ｐｌｕｇｉｎ　ｔｙｐｅ＝＂ａｐｐｌｅｔ／ｂｅａｎ＂　ｃｏｄｅｂａｓｅ＝＂目录＂　ｃｏｄｅ＝＂ＭｙＡｐｐｌｅｔ．ｃｌａｓｓ＂　ｗｉｄｔｈ＝　ｈｅｉｇｈｔ＝＞

类型有ａｐｐｌｅｔ　ｂｅａｎ两种，ｃｏｄｅｂａｓｅ是装该ｊａｖａ文件的文件夹，ｃｏｄｅ表示使用的类是ｃｏｄｅｂａｓｅ下的ＭｙＡｐｐｌｅｔ的ｃｌａｓｓ

##### ｊｓｐ：ｅｌｅｍｅｎｔ／ａｔｔｒｉｂｕｔｅ／ｂｏｄｙ

ｅｌｅｍｅｎｔ用于设置一个元素　＜ｊｓｐ：ｅｌｅｍｅｎｔ　ｎａｍｅ＝＇ｍｙＥｌｅｍｅｎｔ＇＞＜／ｊｓｐ：ｅｌｅｍｅｎｔ＞用于给一个元素起名

ａｔｔｒｉｔｕｂｅ包含在内，用于给该ｍｙＥｌｅｍｅｎｔ添加传入属性

ｂｏｄｙ用于给ｅｌｅｍｅｎｔ添加中间的内容

##### ｊｓｐ：ｔｅｘｔ　只能包含文本和ｅｌ表达式

#### ｊｓｐ隐含对象

JSP隐含对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。

JSP隐含对象也被称为预定义变量。

# EL与JSTL

## JavaBean的基本概念

是一种规范；

1. 实现了java.io.serializable接口
2. 有一个public无参构造函数
3. 有一系列属性
4. 有一系列getter setter

通过jsp动作 <jsp:useBean id="" class="">进行使用

## EL

用于替换脚本表达式： <%=  %> =====> ${expr}

(其实没多大差别)

禁用：<%@ page isELIgnored="true"%>

也可以在EL中使用函数 ${namespace:fn(param)}

使用函数需要使用taglib <%@ taglib prefix="" uri=""%>

prefix决定了namespace

## JSTL

JSP Standard Tag Library JSP标准标签库

使用JSTL前需要<%@ taglib prefix="" uri=""%>



### 核心标签

#### <c:out value= escapeXml= defalut=>

escapeXml对字符进行转义 如果你希望<小于号正常显示 那escapeXml='true'

default是value==null时的默认值



#### <c:set value= var=>

var用于给变量起名字，value是变量的值

也有<c:set target= value= property=>

target是bean对象 

也有<c:set target property>value</c:set>



#### <c:remove var= scope=>

var移除变量名 scope作用域

移除变量后无法通过变量名去访问



#### <c:catch var=><</c:catch>>

用于捕获异常，把异常存于变量中



#### <c:if test= var= scope=>

test存判断条件 var存结果



#### \<c:choose> \<c:when\> \<c:otherwise>

对应switch case else

都是双标签，即<c:choose> /</c:choose/>



#### <c:forEach var items begin end step>

var是当前迭代对象名字的指代

items迭代的集合

begin end是初末位置

step步长



#### <c:fortokens items= delims= var></c:fortokens>

items遍历的字符串

delmis分隔符

var当前迭代对象



#### <c:import url=>

区别于jsp动作 <jsp:include uri=>他只能引入本地对象



#### <c:redirect url=>

可以加参数<c:param name value>



#### <c:url value var>



# JDBC

## 导入JDBC包

```java
import java.sql.*

import java.math.*
```

```java
 // 查询所有的分类信息
 7     // 注意：使用JDBC规范，采用都是java.sql包下的内容
 8     //1 注册驱动
 9     Class.forName("com.mysql.jdbc.Driver");
10     //2 获得连接
11     String url = "jdbc:mysql://localhost:3306/mydb";
12     Connection conn = DriverManager.getConnection(url,"root", "root");
13     //3获得语句执行者
14     Statement st = conn.createStatement();
15     //4执行SQL语句
16     ResultSet rs = st.executeQuery("select * fromcategory"); 
17     //5处理结果集
18     while(rs.next()){
19         // 获得一行数据
20         Integer cid = rs.getInt("cid");
21         String cname = rs.getString("cname");
22         System.out.println(cid + " , " + cname);
23     }
24     //6释放资源
25     rs.close();
26     st.close();
27     conn.close();
```

url是数据库地址

Connection conn=DriverManager.getConnection(url,username,password)

建立连接

Statement st=conn.createStatement()

语句执行者

ResultSet rs=st.executeQuery(执行语句)

通过while(rs.next())遍历,用rs.getType（字段）获取对象

释放资源 ，与获取顺序相反



概括：DriverManager=>Connection=>Statement=>ResultSet



```java
12 <sql:setDataSource var="snapshot" driver="com.mysql.jdbc.Driver"
13      url="jdbc:mysql://localhost/TEST"
14      user="root"  password="pass123"/>
15 
16 <sql:query dataSource="${snapshot}" var="result">
17 SELECT * from Employees;
18 </sql:query>
```

setDataSource 

var给数据库起名 driver驱动 url连接数据库 user password

# MVC设计模式

## 1. MVC 的三个核心组件

### Model（模型）

- **职责：** 负责数据和业务逻辑。
- **功能：** 管理应用程序的状态，直接与数据库进行交互，并定义数据的处理规则（例如：计算价格、验证用户输入）。
- **特点：** 它不关心数据如何显示，也不关心用户如何操作，只专注于数据本身。

### View（视图）

- **职责：** 负责用户界面和数据展示。
- **功能：** 将 Model 中的数据以图形化的方式呈现给用户（如 HTML 页面、APP 界面）。
- **特点：** 视图通常不包含业务逻辑，它只是被动地展示数据。

### Controller（控制器）

- **职责：** 负责转发请求，对请求进行处理。
- **功能：** 充当 Model 和 View 之间的“翻译官”。它接收用户的输入，调用 Model 进行处理，最后决定由哪个 View 来显示结果。

## 2. 两种常用的设计模式（演变模型）

在 Java Web 的发展史上，MVC 主要有两种典型的实现模式：**Model 1** 和 **Model 2**。

### 模式一：Model 1（纯 JSP 或 JSP + JavaBean）

这是 MVC 的早期简化版本。

- **结构：** 视图（JSP）和控制器逻辑（Java 代码）混杂在一起，Model 则是 JavaBean。
- **流程：** 浏览器直接请求 JSP，JSP 负责处理逻辑、访问数据库并展示数据。
- **缺点：** * **耦合严重：** HTML 代码和 Java 代码纠缠在一起，非常混乱。
  - **维护困难：** 逻辑复杂后，修改一个小功能可能需要翻遍整个 JSP 文件。
- **适用：** 极小型的临时项目。

### 模式二：Model 2（Servlet + JSP + JavaBean）

这是标准的 MVC 实现，也是现代 Spring MVC 等框架的基础。

- **结构：**

  - **Controller：** 由 **Servlet** 充当，负责接收请求、逻辑分发。
  - **Model：** 由 **JavaBean** 充当，负责业务数据。
  - **View：** 由 **JSP**（或 Thymeleaf 等）充当，只负责展示。

- 流程： 1.  用户请求发送给 Servlet。

  2.  Servlet 调用 JavaBean 处理业务。

  3.  Servlet 将处理好的结果存入 Request 作用域。

  4.  Servlet 将请求转发给 JSP 渲染页面。

- **优点：** 结构清晰、职责分明，非常利于团队协作和后期维护。

## MVC 的核心优势

| **优势**     | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| **低耦合**   | 修改视图层（比如换一套 UI）不需要改动模型层的代码。          |
| **高重用性** | 同一个模型可以对应多个视图（例如：数据既可以用表格显示，也可以用图表显示）。 |
| **易于维护** | 逻辑分散在不同的组件中，排查问题时目标明确。                 |

# Spring

## 1. Spring 的基本概念：控制反转 (IoC)

在传统的编程模式中，如果类 A 需要用到类 B，我们需要在 A 中手动 `new B()`。但在 Spring 中，对象的创建和生命周期管理交给了 Spring 容器（也叫 IoC 容器）。

- **控制反转 (Inversion of Control, IoC)：** 指的是将对象的控制权（创建、赋值、销毁）从开发者手中交给框架。
- **Bean：** 在 Spring 中，那些被容器管理的对象统一被称为 "Bean"。


## 2. 依赖注入 (Dependency Injection, DI)

DI 是实现 IoC 的具体手段。容器在运行期间，根据配置动态地将依赖对象注入到需要的组件中。

### 常见的注入方式：

1. **构造器注入 (Constructor Injection)：** 通过类的构造函数来注入依赖。这是 Spring 官方目前最推荐的方式，因为它能保证注入的组件不为 null 且不可变。
2. **Setter 注入 (Setter Injection)：** 通过类的 `set` 方法进行注入。这种方式灵活性更高，适合可选依赖。
3. **注解注入 (Annotation Injection)：** 使用 `@Autowired` 或 `@Resource` 注解，直接在属性上进行标记。这是开发中最常用的方式。

## 3. 面向切面编程 (Aspect-Oriented Programming, AOP)

AOP 是对面向对象编程（OOP）的一种补充。它允许我们将那些**与业务主逻辑无关，但在多个模块中重复出现的功能**（如日志记录、性能监控、事务处理、安全性检查）封装起来。

### 为什么要用 AOP？

如果没有 AOP，你可能需要在每个方法里都写一遍“记录开始时间”和“记录结束时间”。有了 AOP，你可以把这段逻辑抽离出来，像“横切”一样插入到目标方法中。

### AOP 的核心术语：

- **Aspect (切面)：** 一个关注点的模块化。比如“日志模块”就是一个切面。
- **Join Point (连接点)：** 程序执行过程中的某个点，比如方法调用时。
- **Advice (通知/增强)：** 在切面在某个特定的连接点上执行的动作。包括：
  - *Before* (前置通知)：方法执行前运行。
  - *After* (后置通知)：方法执行后运行。
  - *Around* (环绕通知)：在方法前后自定义逻辑。
- **Pointcut (切入点)：** 匹配连接点的断言。它决定了通知（Advice）应该应用在哪些方法上。

## 4. IOC 与 AOP 的关系

| **核心概念** | **解决的问题**                   | **核心思想**                               |
| ------------ | -------------------------------- | ------------------------------------------ |
| **IOC / DI** | 解耦对象之间的**依赖关系**。     | 别找我，我会把你需要的东西送过去。         |
| **AOP**      | 解耦业务逻辑与**通用辅助功能**。 | 统一处理重复的横切逻辑，不干扰主业务代码。 |

# 考试心得

布老师的网络应用开发

试卷组成：选择题10x3+*填空题5x3+*简答题5x5+40分编程题；

编程题是一个购物网站的搭建；要求从零开始搭建，并且使用**JSP+Servlet+Mysql**实现；

登陆页面：输入账号和密码，密码正确则跳转到购物车页面；

购物车页面：要求显示所有的购物车记录，每条记录包含商品编号，商品规格，价格，数量，**购买按钮，删除按钮**等属性；

商品界面:显示商品的属性，要有**删除按钮**删除商品

**感觉主要难在用JSP实现**



试卷的理论部分比较简单，考一些比较基本的概念；如果你信得过我说的可以少看点上面概念；

2023简答题考了：

1. cookie与session的区别；
2. spring依赖注入有几种方式；
3. 说明jsp:useBean forward plugin等动作的作用;
4. filter过滤器的工作原理和作用；
5. JDBC数据库的使用流程；

